---
layout: post
title: "关于算法性能分析"
date:   2025-8-11
tags: [碎碎念]
comments: true
author: Venture-Li
---

算法复杂度分为**时间复杂度**和**空间复杂度**。其作用： 时间复杂度是指执行算法所需要的计算工作量；而空间复杂度是指执行这个算法所需要的内存空间。

对于算法性能的分析总是朦朦胧胧，是时候写一个总结，梳理思路也方便日后查看。

> 参考链接：[代码随想录](https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html)  [CSDN](https://blog.csdn.net/swadian2008/article/details/105073428)

## 时间复杂度

**一个算法花费的时间与算法中语句的执行次数成正比例**，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度，记为`T(n)`。

一般情况下，算法中基本操作重复执行的次数是问题规模`n`的某个函数，用`T(n)`表示，若有某个辅助函数`f(n)`，使得当`n`趋近于无穷大时，`T(n)/f(n)` 的极限值为不等于零的常数，则称`f(n)`是`T(n)`的**同数量级函数**。记作`T(n)=O(f(n))`，称`O(f(n))`为算法的**渐进时间复杂度**，简称时间复杂度。

**如果一个算法的执行次数是 `T(n)`，那么只保留最高次项，同时忽略最高项的系数后得到函数 `f(n)`，此时算法的时间复杂度就是 `O(f(n))`。为了方便描述，下文称此为大O推导法。**

时间复杂度是一个数量级，并非准确度量算法运行时间，其运行时间与数据规模、计算机环境息息相关。

### 常见时间复杂度计算

**（1）单个循环体的推导法则**

对于一个循环，假设循环体的时间复杂度为` O(n)`，循环次数为 `m`，则这个循环的时间复杂度为 `O(n×m)`。

```c++
void aFunc(int n) {
    for(int i = 0; i < n; i++) {         // 循环次数为 n
        printf("Hello, World!\n");       // 循环体时间复杂度为 O(1)
    }
}
```

此时时间复杂度为 `O(n × 1)`，即 `O(n)`。

**（2）多重循环体的推导法则**

对于多个循环，假设循环体的时间复杂度为 `O(n)`，各个循环的循环次数分别是`a, b, c...`，则这个循环的时间复杂度为`O(n×a×b×c...)`。分析的时候应该**由里向外**分析这些循环。

```c++
void aFunc(int n) {
    for(int i = 0; i < n; i++) {            // 循环次数为 n
        for(int j = 0; j < n; j++) {        // 循环次数为 n
            printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
        }
    }
}
```

此时时间复杂度为` O(n × n × 1)`，即 `O(n^2)`。

**（3）多个时间复杂度的推导法则**

对于顺序执行的语句或者算法，总的时间复杂度等于其中**最大的时间复杂度**。

```c++
void aFunc(int n) {
    // 第一部分时间复杂度为 O(n^2)
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            printf("Hello, World!\n");
        }
    }
    // 第二部分时间复杂度为 O(n)
    for(int j = 0; j < n; j++) {
        printf("Hello, World!\n");
    }
}
```

此时时间复杂度为 `max(O(n^2)，O(n))`，即 `O(n^2)`。

**（4）条件语句的推导法则**

对于条件判断语句，**总的时间复杂度等于其中时间复杂度最大的路径的时间复杂度**。

```c++
void aFunc(int n) {
    if (n >= 0) {
        // 第一条路径时间复杂度为 O(n^2)
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                printf("输入数据大于等于零\n");
            }
        }
    } else {
        // 第二条路径时间复杂度为 O(n)
        for(int j = 0; j < n; j++) {
            printf("输入数据小于零\n");
        }
    }
}
```

此时时间复杂度为` max(O(n^2), O(n))`，即 `O(n^2)`。

时间复杂度分析的基本策略是：从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析。

**针对`O(logn)`复杂度，其对数的底可以忽略，可用换底公式证明其为常数**

## 空间复杂度

空间复杂度是对一个算法在运行过程中**占用内存空间大小**的量度，记做`S(n)=O(f(n))`。

空间复杂度(Space Complexity)记作`S(n)` 依然使用大O来表示。利用程序的空间复杂度，可以对程序运行中需要多少内存有个**预先估计**。

关注空间复杂度有两个常见的相关问题

1. **空间复杂度是考虑程序（可执行文件）的大小么？**
很多同学都会混淆程序运行时内存大小和程序本身的大小。这里强调一下空间复杂度是**考虑程序运行时占用内存的大小，而不是可执行文件的大小**。

2. **空间复杂度是准确算出程序运行时所占用的内存么？**
不要以为空间复杂度就已经精准的掌握了程序的内存使用大小，很多因素会影响程序真正内存使用大小，例如编译器的内存对齐，编程语言容器的底层实现等等这些都会影响到程序内存的开销。

所以空间复杂度是预先大体评估程序内存使用的大小。

来看一下例子，什么时候的空间复杂度是 `O(1)` 呢，C++代码如下：

```c++
int j = 0;
for (int i = 0; i < n; i++) {
    j++;
}
```

第一段代码可以看出，随着`n`的变化，所需开辟的内存空间并不会随着`n`的变化而变化。即此算法空间复杂度为一个常量，所以表示为大`O(1)`。

什么时候的空间复杂度是`O(n)`？

当消耗空间和输入参数n保持线性增长，这样的空间复杂度为`O(n)`，来看一下这段C++代码

```c++
int* a = new int(n);
for (int i = 0; i < n; i++) {
    a[i] = i;
}
```

我们定义了一个数组出来，这个数组占用的大小为`n`，虽然有一个`for`循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，随着n的增大，开辟的内存大小呈线性增长，即 `O(n)`。

## 递归算法性能分析

递归算法的时间复杂度本质上是要看: **递归的次数 * 每次递归中的操作次数**。

递归算法的空间复杂度为：**每次递归的空间复杂度 * 递归深度**。

对于递归算法复杂度的优化与辨析参考：[代码随想录-递归算法的时间复杂度](https://programmercarl.com/%E5%89%8D%E5%BA%8F/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.html)

