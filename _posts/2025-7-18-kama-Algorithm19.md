---
layout: post
title: "洗盘子"
date:   2025-7-18
tags: [Kama Algorithm]
comments: true
author: Venture-Li
---

## 题目描述

> 在餐厅里，洗盘子的工作需要使用到栈这种数据结构。  
> 假设你手里有一个盘子堆放区。现在需要模拟洗盘子的过程，每个盘子都有一个编号。  
> 盘子堆放区操作说明：  
> 1.当操作为 1 时，表示从盘子堆放区拿走顶部的盘子清洗。  
> 2.当操作为 2 时，表示有未洗的盘子放入盘子堆放区。  
> 在一系列操作之后，你需要回答：下一个清洗的盘子编号？  

## 输入描述

> 第一行有一个整数 n，代表初始盘子堆放区中盘子的数量为 n。  
> 第二行有 n 个整数，代表了盘子的编号，同时整数之间的顺序也代表了未洗盘子加入盘子堆放区的顺序。 
> 第三行为一个整数 m，代表接下来将会有 m 次操作。  
> 接下来一共有 m 行，代表共有 m 次操作。  
> 如果是操作 1，那么该行只会有一个数字 1，代表有一个盘子被拿走清洗。  
> 如果是操作 2，那么该行有两个数字，第一个数字 2 表示有未洗的盘子加入，第二个数字代表未洗的盘子编号。  

## 输出描述

> 输出共一行，为下一个该清洗的盘子编号。 如果没有下一个该清洗的盘子，那么请输出 “All the dishes have been washed.”  

## 输入示例

> 5  
> 1001 1002 1003 1004 1005  
> 3  
> 1  
> 1  
> 2 1006  

## 输出示例

> 1006   

## 题解

```c++
#include <iostream>
#include <stack>
using namespace std;
int main()
{
    int n = 0, num = 0,m = 0;
    cin>>n;
    stack<int> st;
    while(n--)
    {
        cin>>num;
        st.push(num);
    }
    cin>>m;
    while(m--)
    {
        int x = 0;
        cin>>x;
        if(x == 1 && !st.empty())st.pop();
        else if(x == 2)
        {
            int a = 0;
            cin>>a;
            st.push(a);
        }
    }
    if(st.empty())cout<<"All the dishes have been washed."<<endl;
    else cout<<st.top()<<endl;
    return 0;
}
```

---

## 解题技巧

了解**栈**数据结构，掌握**容器适配器**`stack`的基础用法

## 知识背景

### 栈的基本概念

栈的操作实际上和洗盘子的过程是类似的，洗盘子的过程中，会拿出待清洗那一摞盘子的最顶端的那个盘子，清洗之后将其放在已清洗区域，这对于待清洗盘子来说是**出栈**，对于已清洗区域来说，是**入栈（进栈）**，具体的过程可以看下面的图示：

![chart](https://venture-li.github.io/images/202507181927189.png)

栈这种结构只能在一侧（栈顶那一侧）进行插入和删除操作，而且是**后进先出LIFO**(后进入栈的元素离栈顶比较近，先出来)，允许进行插入和删除的那一端是栈顶，与之对应的另一端是栈底, 如果一个栈不包含任何元素，这个栈被称为空栈。

在计算机领域，栈的应用也十分广泛，比如浏览器的历史回退和编写文档时的“撤销”操作。

### stack的使用

C++标准库提供了一个名为 `std::stack` 的栈容器适配器，想要使用它，只需要引入`<stack>`头文件即可。

```c++
#include <stack> // 引入stack头文件
```

然后就可以通过`stack`数据类型 栈名称这样的形式来创建一个栈并进行操作了

```c++
stack<int> st; // 创建一个int类型的栈
```

栈的常用操作主要有以下几种：

- **empty()**: 判断栈是否为空栈，如果为空栈返回true， 否则或者false
- **push()**: 进栈操作，将新的元素放入到栈中，新的元素成为栈顶元素。
- **pop()**： 出栈操作，栈顶元素从栈中离开
- **top()**: 获取栈顶元素，但是不会移除它
- **size()**: 获取栈的长度，即栈中元素的数量

```c++
st.push(1);
st.push(10);
st.push(100); // 往栈中添加元素，现在栈底元素是1，栈顶元素是100

st.pop(); // 移除栈顶元素100，新的栈顶元素是10

int topNumber = st.top(); // 获取栈顶元素10

bool isEmpty = st.empty(); // 如果栈为空，返回true；否则返回false

int stackSize = st.size(); // 获取栈的长度（元素数量）
```
