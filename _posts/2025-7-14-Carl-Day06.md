---
layout: post
title: "Day06| 哈希表基础、242.有效的字母异位词、349.两个数组的交集、202.快乐数、1.两数之和"
date:   2025-7-14
tags: [代码随想录]
comments: true
author: Venture-Li
---

## 哈希表基础

### 哈希表

**哈希表**（英文名字为Hash table，国内也有一些算法书籍翻译为散列表，大家看到这两个名称知道都是指hash table就可以了）。

哈希表是根据**关键码的值而直接进行访问**的数据结构。

![chart](https://venture-li.github.io/images/202507141547240.png)

一般哈希表都是用来**快速判断一个元素是否出现集合里**。

### 哈希函数

例如要查询一个名字是否在这所学校里。

哈希函数，把学生的姓名直接映射为哈希表上的索引，然后就可以通过查询索引下标快速知道这位同学是否在这所学校里了。

哈希函数如下图所示，通过`hashCode`把名字转化为数值，一般`hashcode`是通过特定编码方式，**可以将其他数据格式转化为不同的数值**，这样就把学生名字映射为哈希表上的索引数字了。

![chart](https://venture-li.github.io/images/202507141550795.png)

如果`hashCode`得到的数值大于 哈希表的大小了，也就是大于`tableSize`了，此时为了保证映射出来的索引数值都落在哈希表上，我们会在再次对数值做一个**取模**的操作，这样我们就保证了学生姓名一定可以映射到哈希表上了。

如果学生的数量大于哈希表的大小怎么办，此时就算哈希函数计算的再均匀，也避免不了会有几位学生的名字同时映射到哈希表 同一个索引下标的位置。

接下来**哈希碰撞**登场

#哈希碰撞

如图所示，小李和小王都映射到了索引下标 1 的位置，这一现象叫做哈希碰撞。

![chart](https://venture-li.github.io/images/202507141554111.png)

一般哈希碰撞有两种解决方法， **拉链法**和**线性探测法**。

拉链法将发生冲突的元素存储在链表中。

![chart](https://venture-li.github.io/images/202507141554740.png)

线性探测法，一定要保证tableSize大于dataSize。 不断增加索引，向冲突位置后寻找空位。

![chart](https://venture-li.github.io/images/202507141556508.png)

### 常见的三种哈希结构

当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。

- 数组
- `set` （集合）
- `map`(映射)
  
#### set

在C++中，`set` 和 `map` 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：

![chart](https://venture-li.github.io/images/202507141557490.png)


#### map

![chart](https://venture-li.github.io/images/202507141559882.png)

## 242.有效的字母异位词

> 题目链接：[242.有效的字母异位词](https://leetcode.cn/problems/valid-anagram/description/)  
> 文档讲解：[代码随想录](https://www.programmercarl.com/)  
> 状态：轻松AC

### 思路

从题目信息提炼要求，**字母异位词：字母种类且各个个数均相同**

字母种类**固定**（26个），且每个字母与下表可以产生联系，故选用数组

![chart](https://venture-li.github.io/images/202507142142175.gif)

### 题解

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int arry1[26] = {0};
        int arry2[26] = {0};
        for(auto i:s)arry1[i-'a']++;
        for(auto i:t)arry2[i-'a']++;
        for(int i = 0;i<26;i++)
        {
            if(arry1[i]!=arry2[i])return false;
        }
        return true;
    }
};
```

---

## 349. 两个数组的交集

> 题目链接：[349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/description/)  
> 文档讲解：[代码随想录](https://www.programmercarl.com/)  
> 状态：轻松AC

### 思路

关键点在于**去重**，用`set`不解释

本题学到了一种容器转化方式

```c++
vector<int>(result.begin(),result.end())；//set->vector
unordered_set<int> uset1(nums1.begin(),nums1.end());//vector->set
```

### 题解

```c++
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> uset1(nums1.begin(),nums1.end());
        unordered_set<int> result;
        for(auto i:nums2)
        if(uset1.find(i)!=uset1.end())result.insert(i);
        return vector<int>(result.begin(),result.end());
    }
};
```

---

## 202题.快乐数

> 题目链接：[202题.快乐数](https://leetcode.cn/problems/happy-number/description/)  
> 文档讲解：[代码随想录](https://www.programmercarl.com/)  
> 状态：轻松AC，学习题解“**环**”思想

### 思路

理解本题的本质，若进入循环，且不为1，则一定无解死循环

**本题最后一定死循环，若为1有解，非1无解**

快慢指针思想也可解决，本题一定有环，则**快慢指针一定在环中相遇**，仅需判断是否为1

### 题解

```c++
class Solution {
public:
    int get_sum(int &n){
        int sum = 0;
        while(n!=0)
        {
            int temp = n%10;
            sum += temp*temp;
            n /= 10;
        }
        n = sum;
        return sum;
    }
    bool isHappy(int n) {
    //哈希表思想
        // int sum = 0, temp = 0;
        // unordered_set<int> uset;
        // while(true)
        // {
        //     sum = get_sum(n);
        //     if(uset.find(1) != uset.end())return true;
        //     else if(uset.find(sum) != uset.end())return false;
        //     else uset.insert(sum);
        // }
    //循环思想
        int slow = 0,fast = 0, n2 = n;
        while(true)
        {
            slow = get_sum(n);
            int temp = get_sum(n2);
            fast = get_sum(n2);
            if(slow == fast && slow == 1)return true;
            else if(slow == fast)return false;
        }
    }  
};
```

---

## 1.两数之和

> 题目链接：[1.两数之和](https://leetcode.cn/problems/two-sum/description/)  
> 文档讲解：[代码随想录](https://www.programmercarl.com/)  
> 状态：看了眼思路轻松AC

### 思路

思考过程：一层`for`循环逐个遍历数组（假设为`i`），若想达到目标，要找到`target-i`,并且找到`target-i`的下标.

当然可以暴力，`O(n^2)`

可以设置一个集合（哈希表是根据**关键码的值而直接进行访问**的数据结构），若`target-i`可以被`find`（**且不为自身**），则成功

先别着急，题目是让返回下标呀，下标与值要联系起来，妥妥的`map`没跑了

### 题解

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        map<int,int> umap;
        vector<int> result;
        for(int i = 0;i<nums.size();i++)umap[nums[i]] = i;
        for(int i = 0;i<nums.size();i++)
        {
            if(umap.find(target-nums[i])!=umap.end()&& i!=umap[target-nums[i]])
            {
                result.push_back(i);
                result.push_back(umap[target-nums[i]]);
                return result;
            }
        }
        return result;
    }
};
```




























































































































































































































































































































































































































































































































---
layout: post
title: "开房门"
date:   2025-7-14
tags: [Kama Algorithm]
comments: true
author: Venture-Li
---

## 题目描述

> 假设你手里有一串钥匙，这串钥匙上每把钥匙都有一个编号，对应着一个房门的编号。现给你一个房门编号，你需要判断是否能够打开该房门。

## 输入描述

> 测试数据共有多组。  
> 第一行为一个整数 s，表示共有多少组测试数据。  
> 每组第一行有一个整数 n，表示钥匙串上有多少把钥匙。  
> 后面共有 n 行输入，每行两个整数，第一个整数 k 表示钥匙编号，第二个整数 d 表示房门编号。  
> 最后一行有一个整数 x，表示需要打开的房门编号。  

## 输出描述

> 有多组输出，每组输出占一行。 

## 输入示例

> 2  
> abcdeef  
> aabbccddeeff  

## 输出示例

> e  
> a   

## 题解

```c++
// #include <iostream>
// #include <vector>
// using namespace std;
// int main()
// {
//     int s = 0, n = 0;
//     cin>>s;
//     while(s--)
//     {
//         vector<int> vec1;
//         vector<int> vec2;
//         cin>>n;
//         for(int i = 0;i<n;i++)
//         {
//             int a = 0, b = 0;
//             cin>>a>>b;
//             vec1.push_back(a);
//             vec2.push_back(b);
//         }
//         int x = 0;
//         cin>>x;
//         for(int i = 0;i<n;i++)
//         {
//             if(vec2[i] == x){cout<<vec1[i]<<endl;break;}
//             if(i == n-1)cout<<"Can't open the door."<<endl;
//         }
//     }
//     return 0;
// }
#include <iostream>
#include <unordered_map>
#include <map>
using namespace std;
int main()
{
    int s = 0, n = 0, key = 0, door = 0;
    cin>>s;
    while(s--)
    {   
        int flag = 0;
        cin>>n;
        unordered_map<int,int> umap;
        while(n--)
        {
            cin>>key>>door;
            umap[door] = key;
        }
        int x = 0;
        cin>>x;
        for(const pair<int,int>& KV : umap)
        {
            if(KV.first == x)
            {
                cout<< KV.second << endl;
                flag = 1;
                break;
            }
        }
        if(!flag)cout<< "Can't open the door." << endl;
    }
    return 0;
}
```

---

## 解题技巧

很明显的字典，需要掌握`map`容器数据类型

## 知识背景

### map容器介绍

我们常常把`map`称之为映射，就是将一个元素（通常称之为`key`键）与一个相对应的值（通常称之为`value`）关联起来，比如说一个学生的姓名（`key`）有与之对应的成绩(`value`)，它们是一一对应的，就好像一把钥匙开一扇门，在`map`中键是唯一的，也只有一个唯一的确定的值。

在C++中，`map`提供了以下三种数据结构，其底层实现以及优劣如下表所示：

> map中的键是唯一的，但是multimap则没有此限制

![chart](https://venture-li.github.io/images/202507141524183.png)

`std::unordered_map` 的`key`值存储是**无序**的，底层实现为**哈希表**，查找速度更快，如果不需要排序而只是快速查找键对应的值，可以考虑使用。

`std::map` 和`std::multimap` 的底层实现是红黑树，它的`key`值存储是**有序**的，如果需要对键值对进行自定义排序，可以考虑使用`std::map`。

### map的使用

使用映射容器需要引入头文件`<unordered_map>`或者`<map>`

```c++
// 引入unordered_map头文件，包含unordered_map类型
#include <unordered_map>
// 引入map头文件，包含map类型和multimap类型
#include <map>
```

想要声明`map`映射关系，需要指定键的类型和值的类型。

```c++
// 声明一个整数类型映射到整数类型的 无序映射
unordered_map<int, int> uMap;
// 声明一个将字符串映射到整数的`map`，可以这样声明：
map<string, int> myMap;
```

想要插入键值对`key-value`, 需要使用`insert()`函数或者使用`[]`操作符来插入。如果键不存在，`[]`操作符将会创建一个新的键值对，将其插入到`map`中，并将值初始化为默认值（对于整数来说，默认值是**0**）。

```c++
uMap[0] = 10;
uMap[10] = 0;
myMap["math"] = 100;
myMap["english"] = 80;
```

和`set`类似，可以使用`find`函数来检查某个键是否存在于`map`中，它会返回一个**迭代器**。如果键存在，迭代器指向该键值对，否则指向map的末尾。

```c++
if (myMap.find("math") != myMap.end()) {
    // 键存在
} else {
    // 键不存在
}
```

你可以使用范围`for`循环来遍历`map`中的所有键值对，进行各种操作。

```c++
for(const pair<int,int>& kv:umap) {
  
}
```

当使用范围`for`循环遍历`map`时，我们需要声明一个变量`kv`来存储每个键值对。这个变量的类型通常是`pair`**类型**，下面就让我们详细解释一下`const pair<int,int>& kv:umap`

`const`用于声明一个**不可修改**的变量，这意味着一旦变量被初始化，就不能再修改其值。常量通常用大写字母表示

因为`const`声明的变量一旦创建后就无法修改值，所以**必须初始化**。

在这里，`const`关键字表示你**只能读取容器中的元素，而不能修改**它们。

而`pair<int, int>`定义了kv也就是键值对的数据类型是`pair`, C++中的`pair`类型会将两个不同的值组合成一个单元， 常用于存储键值对，创建`pair`的时候，也必须提供两个类型名，比如上面的`pair`对象，两个值的类型都是`int`， 在使用时通过`first` 和 `second` 成员来访问 `pair` 中的第一个和第二个元素, 它的 `first` 成员存储键，而 `second` 成员存储值。

`&`：这个符号表示`kv`是一个引用（`reference`），而不是值的拷贝, 如果不使用引用的话，那在每次循环迭代中都会重新创建一个新的`pair`对象来复制键值对，而这会导致不必要的内存分配和拷贝操作。

### 范围for循环(C++11)

C++11引入了范围`for`循环，用于更方便地遍历容器中的元素。这种循环提供了一种简单的方式来迭代容器中的每个元素，而不需要显式地使用迭代器或索引。

```c++
for (类型 变量名 : 容器) {
    // 在这里使用一个变量名，表示容器中的每个元素
}
```

比如下面的代码就表示使用范围`for`循环遍历一个容器

```c++
std::vector<int> numbers = {1, 2, 3, 4, 5};

// 使用范围for循环遍历向量中的元素
for (int num : numbers) {
    std::cout << num << " ";
}
```

范围`for`循环**不会修改容器中的元素**，它只用于读取元素。如果需要修改容器中的元素，需要使用传统的`for`循环或其他迭代方式。

此外，还可以使用`auto`关键字来让编译器自动推断元素的类型，这样代码会更通用

```c++
// 使用auto关键字自动推断元素的类型
for (auto num : numbers) {
    std::cout << num << " ";
}
```

## 总结
到此，哈希表的三种实现，数组、set, map的基本使用都已经全部讲解完了，哈希表有三种实现，那什么时候用数组，什么时候用set，什么时候用map呀，这个问题，在后面去刷代码随想录的 哈希表章节时，就会了解的更深入了。
