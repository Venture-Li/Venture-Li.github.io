---
layout: post
title: "Day31| 56.合并区间、738.单调递增的数字、968.监控二叉树、贪心算法总结"
date:   2025-8-8
tags: [代码随想录]
comments: true
author: Venture-Li
---

## 56.合并区间

> 题目链接：[56.合并区间](https://leetcode.cn/problems/merge-intervals/description/)  
> 文档讲解：[代码随想录](https://www.programmercarl.com/)  
> 状态：轻松AC  

### 思路

与之前重叠区间问题类似，排序遍历即可，灰常简单。

### 题解

```c++
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        sort(intervals.begin(),intervals.end());
        res.push_back(intervals[0]);
        for(int i = 1;i<intervals.size();i++)
        {   
            if(intervals[i][0]<=res.back()[1])
            {
                res.back()[1] = max(res.back()[1],intervals[i][1]);
                //intervals[i] = res[res.size()-1];
            }
            else res.push_back(intervals[i]);
        }
        return res;
    }
};
```

---

## 738.单调递增的数字

> 题目链接：[738.单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/description/)  
> 文档讲解：[代码随想录](https://www.programmercarl.com/)  
> 状态：看思路后多次尝试AC

### 思路

贪心模拟题目，没有什么思路可言，就是自己动手写一下想一下就可以找到规律。

做了本题之后，在力扣做题有了一些经验，一些题目没有思路时，可以自己写一写`case`去测试，找规律。

### 题解

```c++
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        string s = to_string(n);
        int location = s.size();
        for(int i = s.size()-1;i>=1;i--)
        {
            if(s[i-1]>s[i] || location == i && s[i-1] == s[i])location = i-1;
        }
        for(int i = location;i<s.size();i++)
        {
            if(i == location)s[location]--;
            else s[i] = '9';
        }
        return stoi(s);
    }
};
```

---

## 968.监控二叉树——待做

---

## 贪心算法总结

贪心算法很简单，在思考中为：**某种情况下最优->全局最优**

没有套路，都是脑子

给一张密密麻麻的欣炜图：

![chart](https://venture-li.github.io/images/202508091556857.png)

图片来源于 [知识星球-海螺人](https://wx.zsxq.com/dweb2/index/footprint/844412858822412)
